# atomic-oop

В `record.hpp` хранится структура Record (она никак не изменялась, 1 в 1 как на лекции) + функция для вывода её в stdout.

В `atomic_change.hpp` хранятся шаблонные классы:
* `KeyValuePair`: пара ключ-значение
* `KeyValueArgument`: генератор пар ключ-значение
* `AtomicChange`: класс, который принимает все переданные ему пары ключ-значение и передает их выбранному объекту

В `atomic_record.hpp` объявлены генераторы пар ключ-значение `name`, `age` и `position`. Причем они объявлены как constexpr, поэтому смею предположить, что в статической памяти их нет, а пары ключ-значение, генерируемые ими, создаются в компайл-тайме. Также перегружен метод `SetKeyValue`, который вызывается в `AtomicChange`, чтобы передать соответствующее изменение в `Record`.

В теории, такой `.hpp` файл можно создать для любой структуры: достаточно создать соответствующие генераторы пар ключ-значение и перегрузить `SetKeyValue`, чтобы передавать такие пары в объект. Только смущают возможные коллизии этих constexpr-ов, как такое обходить я не придумал.

Да и вообще, система странная, выглядит именно что как "обход" фич С++, а не использование имеющихся фич по назначению.

**UPD:** Добавил еще один пример: `car.hpp` и соответственно `atomic_car.hpp`. В функции `main` они друг с другом спокойно уживаются. Для добавления этого примера не пришлось менять ничего внутри `atomic_change.hpp`, что есть хорошо (типа хорошая масштабируемость и все дела???).
